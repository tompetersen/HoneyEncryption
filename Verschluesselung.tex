\subsection{Eine DTE für private RSA-Schlüssel}

Das folgende Beispiel ist entnommen aus \cite{EURO2014}.

Bei RSA handelt es sich um einen asymmetrischen Verschlüsselungsalgorithmus, d.h. das Verfahren beruht auf einem öffentlichen und einem privaten Schlüssel. Zur Generierung der Schlüssel (heutiger Stand: 2000 Bit \cite{BSI2014}) wählt man zwei große  Primzahlen \(p\) und \(q\) und errechnet aus ihnen öffentlichen und privaten Schlüssel (zu Details siehe \cite{Schneier2006}). RSA wird beispielsweise bei SSL/TLS oder SSH eingesetzt. Für die Anwendung von Honey Encryption ist jedoch nur der zweite Fall geeignet, denn bei SSL/TLS ist der öffentliche Schlüssel des Servers bekannt und so ließe sich leicht nachprüfen, ob der richtige private Schlüssel entschlüsselt wurde. 

Bei SSH lässt sich Honey Encryption jedoch anwenden. In diesem Fall wird der öffentliche Schlüssel zum Zweck der Authentifizierung auf dem Server gespeichert, den man erreichen möchte (und steht somit dem Angreifer nicht zur Verfügung). Der private Schlüssel (genauer \(p\) und \(q\) zusammen mit weiteren berechneten Werten, um die Ver- bzw. Entschlüsselung nach dem Chinesischen Restsatz zu erleichtern) wird verschlüsselt auf dem Clientsystem gespeichert. 

Zur Erstellung einer DTE für RSA-Schlüssel muss betrachtet werden, wie die Primzahlen \(p\) und \(q\) (im Folgenden werden Primzahlen aus dem Intervall \([2^{l-1},2^l)\) gefordert) bezogen werden. Normalerweise werden zufällige Zahlen aus dem Intervall gezogen und durch einen Primzahltest (Miller-Rabin-Test) wird überprüft, ob es sich dabei um Primzahlen handelt. DIes wird solange wiederholt, bis man zwei Primzahlen gefunden hat. 

Ein naiver Ansatz für eine DTE wäre es, die beiden gefundenen Primzahlen als \((l-2)\)-Bitstrings zu dekodieren (die auf jeden Fall vorhandene führende 1 ist implizit und wird ausgelassen). Da jedoch bei der Entschlüsselung dann auch nicht Primzahlen entstehen würden (und zwar nach dem Primzahlsatz mit etwa Wahrscheinlichkeit \(1-\frac{1}{l}\)), würde ein Angreifer viele Ausgaben von vornherein als "falsch" erkennen können.

Daher schlägt \cite{EURO2014} ein anderes Vorgehen vor. Zur Kodierung von \(p\) und \(q\) wird ein Vektor vonj \(t\) zufälligen \((l-2)\)-Bitstrings angelegt. Per Primzahltest werden die Zahlen überprüft. Die ersten beiden Primzahlen in dem Vektor werden durch \(p\) und \(q\) ersetzt. Enthält der Vektor nur eine Primzahl, so wird diese durch \(p\) und die letzte Zahl durch \(q\) ersetzt. Enthält der Vektor keine Primzahlen, so ersetzen \(p\) und \(q\) die letzten beiden Zahlen. Beim Dekodieren werden die ersten beiden Primzahlen im Vektor ausgegeben. Wenn der Vektor keine zwei Primzahlen enthält so werden fest kodierte Proimzahlen ausgegeben.

Es lässt sich zeigen, dass ein Angreifer, der versucht \(p\) und \(q\) per Brute-Force-Angriff zu erhalten, eine  Erfolgswahrscheinlichkeit von höchstens \((1-\frac{2}{3l})^{t-1}\) besitzt (ebenfalls \cite{EURO2014}). Damit lässt sich also die Erfolgswahrscheinlichkeit des Angreifers durch Nutzung eines größeren Vektors verringern (allerdings auf Kosten von größerem Speicherplatzbedarfs).

Ein anderer Ansatz, der in \cite{EURO2014} erwähnt wird, wäre die Kodierung des Seeds/Keys, der zur Initialisierung des Zufallszahlengenerators verwendet wurde, um \(p\) und \(q\) zu generieren. Eine DTE wäre trivial, da es sich bei dem Seed/Key im Allgemeinen um einen kurzen, zufällig gleichverteilten String handelt. 

\section{Verschlüsselungsschema}
\label{sec:schema}

Nachdem eine Nachricht aus dem Message Space - wie in Kapitel \ref{sec:dte} beschrieben - durch eine DTE auf den Seed Space abgebildet wurde, folgt die Verschlüsselung des Ergebnisses. Hierfür schlägt \cite{EURO2014} zwei verschiedene Vorgehensweisen vor. Die unter Verwendung dieser Vorgehensweisen entstehenden Honey Encryption-Schemata werden im Folgenden dargestellt.

\subsection{Hashbasierte Verschlüsselung}

Das erste Verfahren nutzt zur Verschlüsselung die XOR-Verknüpfung des aus der Nachricht erhaltenen Seeds \(S\) mit einem Hash des Schlüssels \(K\) (Abbildung \ref{fig:HashEnc}).  

Nach der Kodierung der Nachricht durch die DTE wird der Schlüssel zum Erschweren von Brute-Force-Angriffen durch eine Password Based Key Derivation Function auf den Bitstring \(K_D\) abgebildet. Es wird ein zufälliger Bitstring \(R\) gewählt, der zusammen mit \(K_D\) durch die Hashfunktion HF auf \(H\) abgebildet wird. Dieser zufällige Bitstring sorgt dafür, dass auch bei der Verschlüsselung gleicher Nachrichten mit gleichem Schlüssel unterschiedliche Chiffretexte entstehen. Er kann je nach Anwendung in der Länge \(k\) variiert werden. Der errechnete Hash \(H\) wird nun mit dem im ersten Schritt erhaltenen Seed \(S\) XOR-verknüpft und bildet den Chiffretext \(C\). Dieser kann nun zusammen mit dem Bitstring \(R\) gespeichert oder übertragen werden. 

\begin{figure}[h]
	\begin{minipage}[b]{0.5\textwidth}
		\begin{align*}
			\text{HEnc}&_{\text{Hash}}(M, K)\\
			&S \overset{<r>}{=} \text{DTE}(M)\\ 	%Encoding
			&K_D = \text{PBKDF}(K)\\ 		%PBKDF2
			&R \overset{<r>}{=} \{0,1\}^k\\	%Random
			&H = \text{HF}(K_D,R)\\	%Hash
			&C = H \oplus S\\	%XOR
			&\text{Return } (C,R)
		\end{align*}
		\caption{Hashbasierte Verschlüsselung}
		\label{fig:HashEnc}
	\end{minipage}
	\begin{minipage}[b]{0.5\textwidth}
		\begin{align*}
			\text{HDec}&_{\text{Hash}}((C,R), K)\\
			&K_D = \text{PBKDF}(K)\\ 		%PBKDF2
			&H = \text{HF}(K_D,R)\\	%Hash
			&S = H \oplus C\\	%XOR
			&M = \text{DTE}^{-1}(S)\\ 	%Encoding
			&\text{Return } M
		\end{align*}
		\caption{Hashbasierte Entschlüsselung}
		\label{fig:HashDec}
	\end{minipage}
\end{figure}

Zur Entschlüsselung wird das Verfahren in ähnlicher Weise durchlaufen (Abbildung \ref{fig:HashDec}). Der Schlüssel \(K\) wird wie bei der Verschlüsselung durch eine Password Based Key Derivation Function auf den Bitstring \(K_D\) abgebildet. Zusammen mit dem übergebenen Bitstring \(R\) wird durch HF der Hash \(H\) gebildet. Durch eine XOR-Verknüpfung von \(H\) mit \(C\) erhält man den ursprünglichen Seed \(S\). Dieser kann dann durch die DTE  dekodiert werden und es ergibt sich wieder die Nachricht \(M\).

\subsection{Auf Blockchiffren basierte Verschlüsselung}

Für die Verschlüsselung können jedoch auch Blockchiffren genutzt werden. Im Folgenden wird das Schema unter Nutzung einer Blockchiffre mit dem CTR-Modus skizziert. Andere Betriebsmodi sollten ebenfalls nutzbar sein (so erwähnt \cite{EURO2014} explizit den CBC-Modus), jedoch müssten im Einzelfall Einschränkungen, wie Blocklänge oder eventuell notwendiges Padding, beachtet werden. 

\begin{figure}[h]
	\begin{minipage}[b]{0.5\textwidth}
		\begin{align*}
			\text{HEnc }&_{\text{Block}}(M, K)\\
			&S \overset{<r>}{=} \text{DTE}(M)\\ 	%Encoding
			&R \overset{<r>}{=} \{0,1\}^k\\	%Random
			&K' = \text{HF}(K,R)\\ 		%Hash
			&P = \epsilon \\
			&\text{For } i = 1 \text{ to } \left\lceil \frac{|S|}{n} \right\rceil \\
			&\qquad P = P \text{ || Enc}(K',i)\\	%Enc
			&C = P[1 .. |S|] \oplus S\\	%XOR
			&\text{Return } (C,R)
		\end{align*}
		\caption{Verschlüsselung mit Blockchiffre (CTR-Modus)}
		\label{fig:BlockEnc}
	\end{minipage}
	\begin{minipage}[b]{0.5\textwidth}
		\begin{align*}
			\text{HDec }&_{\text{Block}}((C,R), K)\\
			&K' = \text{HF}(K,R)\\ 		%Hash
			&P = \epsilon \\
			&\text{For } i = 1 \text{ to } \left\lceil \frac{|S|}{n} \right\rceil \\
			&\qquad P = P \text{ || Enc}(K',i)\\	%Enc
			&S = P[1 .. |S|] \oplus C\\	%XOR
			&M = \text{DTE}^{-1}(S)\\ 	%Encoding
			&\text{Return } M
		\end{align*}
		\caption{Entschlüsselung mit Blockchiffre (CTR-Modus)}
		\label{fig:BlockDec}
	\end{minipage}
\end{figure}

Sowohl bei der Ver- als auch bei der Entschlüsselung wird zum Erzeugen eines Schlüsselstroms (gemäß dem CTR-Modus für Blockchiffren) gleich vorgegangen (sieht man einmal von der Erzeugung des zufälligen Bitstrings \(R\) der Länge \(k\) während der Verschlüsselung ab, der aus dem gleichen Grund wie bei dem hashbasierten Verfahren genutzt wird). Aus \(R\) und dem Schlüssel \(K\) wird durch eine Hashfunktion der Schlüssel \(K'\) generiert. Der Schlüsselstrom \(P\) wird leer initialisiert. Nun wird eine Schleife so oft durchlaufen wie Blöcke der Länge \(n\) (Blocklänge der verwendeten Blockchiffre) notwendig sind, um mindestens die Länge eines Seedwertes (\(|S|\)) zu erreichen. In jedem Durchlauf wird an \(P\) die Blockverschlüsselung von \(K'\) und dem Schleifenzähler \(i\) angehängt.

Bei der Verschlüsselung (Abbildung \ref{fig:BlockEnc}) wird der aus der Kodierung entstandene Seed \(S\) mit den \(|S|\) ersten Bits des wie bereits beschrieben berechneten Schlüsselstrom \(P\) XOR-verknüpft und bildet so den Chiffretext \(C\), der zusammen mit \(R\) nun gespeichert oder übertragen werden kann.

Bei der Entschlüsselung (Abbildung \ref{fig:BlockDec}) müssen nach Berechnung des Schlüsselstroms \(P\) nur noch die \(|S|\) ersten Bits von \(P\) mit \(C\) XOR-verknüpft werden und man erhält den ursprünglichen Seed \(S\). Dieser kann dann durch die DTE  dekodiert werden und es ergibt sich wieder die Nachricht \(M\).

\newpage